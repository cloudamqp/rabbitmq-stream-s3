%% Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
%% SPDX-License-Identifier: Apache-2.0
%% vim:ft=erlang:
%% -*- mode: erlang; -*-

{mapping, "s3.region", "rabbitmq_stream_s3.aws_region", [
    {datatype, binary}
]}.

{translation, "rabbitmq_stream_s3.aws_region",
fun(Conf) ->
    case cuttlefish:conf_get("s3.region", Conf, undefined) of
        undefined -> cuttlefish:unset();
        Value     -> Value
    end
end}.

%% A mapping between region name and top-level domain names.
{mapping, "s3.region_endpoints.$region", "rabbitmq_stream_s3.aws_region_endpoints", [
    {datatype, [binary]}
]}.

{translation, "rabbitmq_stream_s3.aws_region_endpoints",
fun(Conf) ->
    case cuttlefish_variable:filter_by_prefix("s3.region_endpoints", Conf) of
        [] ->
            cuttlefish:unset();
        Settings ->
            lists:foldl(
              fun ({["s3", "region_endpoints", Region0], TLD}, Acc) ->
                      Acc#{list_to_binary(Region0) => TLD};
                  (Other, _Acc) ->
                      cuttlefish:invalid(
                        lists:flatten(io_lib:format("~p is invalid", [Other])))
              end, #{}, Settings)
    end
end}.

%% access_key_id

{mapping, "s3.access_key_id", "rabbitmq_stream_s3.aws_access_key", [
    {datatype, binary}
]}.

{translation, "rabbitmq_stream_s3.aws_access_key",
fun(Conf) ->
    case cuttlefish:conf_get("s3.access_key_id", Conf, undefined) of
        undefined -> cuttlefish:unset();
        Value     -> Value
    end
end}.

%% secret_key

{mapping, "s3.secret_key", "rabbitmq_stream_s3.aws_secret_key", [
    {datatype, binary}
]}.

{translation, "rabbitmq_stream_s3.aws_secret_key",
fun(Conf) ->
    case cuttlefish:conf_get("s3.secret_key", Conf, undefined) of
        undefined -> cuttlefish:unset();
        Value     -> Value
    end
end}.

{mapping, "s3.account_id", "rabbitmq_stream_s3.aws_account_id", [
    {datatype, binary}
]}.

{translation, "rabbitmq_stream_s3.aws_account_id",
fun(Conf) ->
    case cuttlefish:conf_get("s3.account_id", Conf, undefined) of
        undefined -> cuttlefish:unset();
        Value     -> Value
    end
end}.

{mapping, "s3.bucket", "rabbitmq_stream_s3.bucket", [
    {datatype, binary}
]}.

{translation, "rabbitmq_stream_s3.bucket",
fun(Conf) ->
    case cuttlefish:conf_get("s3.bucket", Conf, undefined) of
        undefined -> cuttlefish:unset();
        Value     -> Value
    end
end}.


{mapping, "s3.read_ahead", "rabbitmq_stream_s3.read_ahead", [
    {datatype, string},
    {validators, ["is_supported_information_unit"]}
]}.

{validator, "is_supported_information_unit", "supported formats: 500MB, 500MiB, 10GB, 10GiB, 2TB, 2TiB, 10000000000",
 fun(S0) ->
         %% this is a string
         S = string:strip(S0, right),
         %% The suffix is optional
         {ok, HasIUSuffix} = re:compile("([0-9]+)([a-zA-Z]){1,3}$", [dollar_endonly, caseless]),
         {ok, SuffixExtractor} = re:compile("(k|ki|kb|kib|m|mi|mb|mib|g|gi|gb|gib|t|ti|tb|tib|p|pi|pb|pib)$", [dollar_endonly, caseless]),
         case re:run(S, HasIUSuffix) of
             nomatch -> false;
             {match, _} ->
                 case re:split(S, SuffixExtractor) of
                     [] -> false;
                    [_CompleteMatch] -> false;
                     [_CompleteMatch, Suffix | _] -> true
                 end
         end
  end}.

%% S3 tiered storage for Osiris.

{mapping, "streams.log_reader", "osiris.log_reader", [
    {datatype, {enum, [osiris_log, rabbitmq_stream_s3_log_reader]}}
]}.
{mapping, "streams.log_manifest", "osiris.log_manifest", [
    {datatype, {enum, [osiris_log, rabbitmq_stream_s3_log_manifest]}}
]}.
